
import random
import time
import os
import board
import threading 
from adafruit_motorkit import MotorKit
from adafruit_motor import stepper
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.textinput import TextInput
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.scrollview import ScrollView
from kivy.uix.image import Image
from kivy.clock import Clock
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.ndimage import gaussian_filter
from datetime import datetime
from kivy.core.window import Window
from kivy.uix.widget import Widget
from kivy.graphics import Color, Rectangle
from kivy.uix.floatlayout import FloatLayout
import requests


# Global Variables
data_matrix = []
IMAGE_DIRECTORY = "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection/KIVY GUI"
current_x_velocity = 0
current_y_velocity = 0.0
x_velocities = []
y_velocities = []



#Fucntion to Reset axes
def reset_axes(motor_x, motor_y, steps_per_mm, travel_distance_x=110, travel_distance_y=130):
    x_reset_distance = 5  # Stop 5 mm from origin
    y_reset_distance = travel_distance_y

    x_steps_to_reset = int((travel_distance_x - x_reset_distance) * steps_per_mm)
    y_steps_to_reset = int(y_reset_distance * steps_per_mm)

    print("Resetting Y-axis to origin...")
    move_motor(motor_y, y_steps_to_reset, stepper.BACKWARD)
    print("Y-axis reset complete.")

    print("Resetting X-axis to 5 mm from origin...")
    move_motor(motor_x, x_steps_to_reset, stepper.BACKWARD)
    print("X-axis reset complete.")


# Function to move the Z-axis actuator

def move_third_actuator(motor_z, distance_mm, steps_per_mm=10):
    print(f"Moving Z-axis by {distance_mm} mm...")
    steps = int(distance_mm * steps_per_mm)
    for _ in range(steps):
        motor_z.onestep(direction=stepper.FORWARD)
        time.sleep(0.01)
    print("Z-axis movement complete.") 

 

# Fucntion Move Motor
def move_motor(motor, steps, direction):
    start_time = time.time()
    for _ in range(steps):
        motor.onestep(direction = direction)
        time.sleep(0.002)
    end_time = time.time()
    return end_time - start_time

# Helper to safely schedule velocity updates from threads
def update_velocity_scheduled(xv, yv, update_velocity):
    def updater(dt):
        update_velocity(xv, yv)
    return updater



        
# Function to continuously read ADC in a separate thread
def acquire_adc_data(chan, sampling_rate, data_list, stop_event):
    interval = 1 / sampling_rate  # How often to sample ADC
    while not stop_event.is_set():
        data_list.append(chan.voltage)  # Read actual ADC value
        time.sleep(interval)  # Sleep based on sampling rate

#Zig Zag Fucntion
def move_in_zigzag_pattern(motor_x, motor_y, chan, sampling_rate, step_increment_y, steps_per_mm,update_velocity):
    global data_matrix, x_velocities, y_velocities
    data_matrix = []
    print(f"Starting zig-zag scan with sampling rate {sampling_rate} Hz and Y-axis increment {step_increment_y} mm...")

    total_x_steps = int(110 * steps_per_mm)
    total_y_steps = int(step_increment_y * steps_per_mm)
    total_y_increments = int(130 / step_increment_y)
    y_increment_count = 0

    stop_event = threading.Event()

    for i in range(total_y_increments):
        
        # Forward X scan
        row_data = []
        stop_event.clear()
        adc_thread = threading.Thread(target=acquire_adc_data, args=(chan, sampling_rate, row_data, stop_event))
        adc_thread.start()
        global current_x_velocity, current_y_velocity
        duration = move_motor(motor_x, total_x_steps, stepper.FORWARD)
        stop_event.set()
        adc_thread.join()
        data_matrix.append(row_data)
        
        # Calculate and update velocity
        
        
        x_velocity = 110 / duration if duration > 0 else 0
        y_velocity = step_increment_y / (0.002 * total_y_steps)
        #current_x_velocity = x_velocity
        #current_y_velocity = y_velocity
        print(f"[Terminal] X Velocity: {x_velocity:.2f} mm/s, Y Velocity: {y_velocity:.2f} mm/s")
        x_velocities.append(x_velocity)
        y_velocities.append(y_velocity)
        
        



        move_motor(motor_y, total_y_steps, stepper.FORWARD)
        y_increment_count += 1
        if y_increment_count > total_y_increments + 1:
            break

        # Backward X scan
        row_data = []
        stop_event.clear()
        adc_thread = threading.Thread(target=acquire_adc_data, args=(chan, sampling_rate, row_data, stop_event))
        adc_thread.start()
        duration=move_motor(motor_x, total_x_steps, stepper.BACKWARD)
        stop_event.set()
        adc_thread.join()
        row_data.reverse()
        data_matrix.append(row_data)
        
        
        x_velocity = 110 / duration if duration > 0 else 0
        y_velocity = step_increment_y / (0.002 * total_y_steps)
        #current_x_velocity = x_velocity
        #current_y_velocity = y_velocity
        print(f"[Terminal] X Velocity: {x_velocity:.2f} mm/s, Y Velocity: {y_velocity:.2f} mm/s")
        x_velocities.append(x_velocity)
        y_velocities.append(y_velocity)
        
        




        move_motor(motor_y, total_y_steps, stepper.FORWARD)
        y_increment_count += 1
        if y_increment_count > total_y_increments + 1:
            break
    
    avg_x_velocity = sum(x_velocities) / len(x_velocities) if x_velocities else 0
    avg_y_velocity = sum(y_velocities) / len(y_velocities) if y_velocities else 0

    Clock.schedule_once(lambda dt: update_velocity(avg_x_velocity, avg_y_velocity))
    
    print("✔ Zig-zag scanning complete.")
    


# Function to generate heatmap
def generate_heatmap(data_matrix):
    print("Generating heatmap...")
    max_length = max(len(row) for row in data_matrix)
    padded_data_matrix = np.full((len(data_matrix), max_length), np.nan)
    for i, row in enumerate(data_matrix):
        padded_data_matrix[i, :len(row)] = row
    data_matrix_filtered = gaussian_filter(np.nan_to_num(padded_data_matrix), sigma=1)
    plt.figure(figsize=(10, 8))
    sns.heatmap(data_matrix_filtered, cmap="coolwarm", xticklabels=False, yticklabels=False,
                mask=np.isnan(padded_data_matrix), cbar_kws={'label': 'Voltage (V)','shrink' : 0.8})
    plt.title('mmWave Signal Intensity (V)',fontsize = 20)
    plt.xlabel('X Position (cm)',fontsize = 16)
    plt.ylabel('Y Position (cm)',fontsize = 16)
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    #desktop_path = os.path.join(os.path.expanduser("~"), "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection")
    save_path = "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection/KIVY GUI"
    heatmap_filename = os.path.join(save_path, f"heatmap_{timestamp}.png")
    plt.savefig(heatmap_filename)
    print(f"Heatmap saved as {heatmap_filename}")
    return heatmap_filename

# Intro Screen
class IntroScreen(Screen):
    def __init__(self, **kwargs):
        super(IntroScreen, self).__init__(**kwargs)
        layout = AnchorLayout(anchor_x = 'center', anchor_y = 'center')
        # Add the company logo 
        logo = Image(source='/home/furdeengregg/Downloads/Scan.png', 
                     size_hint=(None, None), size=(500, 500)) 
        layout.add_widget(logo)        
        self.add_widget(layout)

    def on_enter(self):
        Clock.schedule_once(self.switch_to_main, 5)

    def switch_to_main(self, *args):
        self.manager.current = 'main'

# Main Screen
class MainScreen(Screen):
    def __init__(self, **kwargs):
        super(MainScreen, self).__init__(**kwargs)

        # Initialize MotorKit instances
        self.kit1 = MotorKit(address=0x60)  # First bonnet
        self.kit2 = MotorKit(address=0x61)  # Second bonnet
        
        # Define Steps_per_mm
        self.steps_per_mm = 200 /( 2 * 3.14 * 10) 

        # Define motors
        self.motor_x = self.kit1.stepper1
        self.motor_y = self.kit1.stepper2
        self.motor_z = self.kit2.stepper1

        # Initialize I2C and ADC
        i2c = board.I2C()
        ads = ADS.ADS1115(i2c)
        self.chan = AnalogIn(ads, ADS.P0)

        main_layout = BoxLayout(orientation='vertical', padding=20, spacing=20)
        # Title at the top, centered and in red
        title_label = Label(
            text="ScanProTech",
            font_size='40sp',
            color=(1, 0, 0, 1),  # Red color
            bold=True,
            size_hint=(1, None),
            height=50
        ) 
        title_box = BoxLayout(size_hint=(1, None), height=60)
        title_box.add_widget(title_label)
        main_layout.add_widget(title_box)

        content_layout = BoxLayout(orientation='horizontal', spacing=20)
        left_layout = BoxLayout(orientation='vertical', spacing=20, size_hint=(0.8, 1))
        # Use FloatLayout for layering black background and image
        image_container = FloatLayout(size_hint=(1, 0.7))
        with image_container.canvas.before:
            Color(0, 0, 0, 1)  # Black background
            self.bg_rect = Rectangle(size=image_container.size, pos=image_container.pos)

        def update_bg_rect(instance, value):
            self.bg_rect.size = instance.size
            self.bg_rect.pos = instance.pos

        image_container.bind(pos=update_bg_rect, size=update_bg_rect)

        self.image_widget = Image(
            source="",  # Don't use None
            size_hint=(1, 1),
            pos_hint={'x': 0 ,'y': 0},
            opacity=0
        )
        image_container.add_widget(self.image_widget)
        left_layout.add_widget(image_container)
        self.scanned_image_label = Label(text="Scanned Image displayed Here", font_size='20sp', size_hint=(1, None), height=30)
        left_layout.add_widget(self.scanned_image_label)
        bottom_buttons_layout = BoxLayout(orientation='horizontal', size_hint=(1, None), height=60, padding=(10, 10))
        self.previous_scans_button = Button(text="Previous Scans")
        self.scan_now_button = Button(text="Scan Now")
        self.previous_scans_button.bind(on_release=self.open_previous_scans)
        self.scan_now_button.bind(on_release=self.start_scan)
        bottom_buttons_layout.add_widget(self.previous_scans_button)
        bottom_buttons_layout.add_widget(self.scan_now_button)
        left_layout.add_widget(bottom_buttons_layout)
        content_layout.add_widget(left_layout)

        # RAW ADC Values Section
        adc_box = BoxLayout(orientation='vertical', padding=10, spacing=10, size_hint=(1, None), height=100)
        adc_label = Label(text="RAW ADC Values", font_size='20sp', bold=True)
        adc_box.add_widget(adc_label)

        self.adc_data_display = []
        for i in range(5):  # Create 5 labels for example
            label = Label(text=f"Fetching ADC Data {i + 1}...", font_size='16sp')
            self.adc_data_display.append(label)
            adc_box.add_widget(label)  # Add each label to the ADC box
        
        left_layout.add_widget(adc_box)

        # Right Layout for Stages, Velocity, and Display Position
        right_layout = BoxLayout(orientation='vertical', spacing=20, size_hint=(0.4, 1))

        # Stages Box
        stages_box = BoxLayout(orientation='vertical', spacing=10)
        stages_label = Label(text="Stages", font_size='20sp', bold=True)
        stages_box.add_widget(stages_label)

        sampling_layout = BoxLayout(orientation='horizontal', spacing=5)
        sampling_label = Label(text="Sampling Rate:")
        self.sampling_rate_input = TextInput(hint_text="Enter Sampling Rate", multiline=False)
        sampling_layout.add_widget(sampling_label)
        sampling_layout.add_widget(self.sampling_rate_input)
        stages_box.add_widget(sampling_layout)

        y_axis_layout = BoxLayout(orientation='horizontal', spacing=5)
        y_axis_label = Label(text="Y-axis:")
        self.y_axis_input = TextInput(hint_text="Enter Y-axis Value", multiline=False)
        y_axis_layout.add_widget(y_axis_label)
        y_axis_layout.add_widget(self.y_axis_input)
        stages_box.add_widget(y_axis_layout)

        z_axis_layout = BoxLayout(orientation='horizontal', spacing=5)
        z_axis_label = Label(text="Z-axis:")
        self.z_axis_input = TextInput(hint_text="Enter Z-axis Value", multiline=False)
        z_axis_layout.add_widget(z_axis_label)
        z_axis_layout.add_widget(self.z_axis_input)
        stages_box.add_widget(z_axis_layout)

        right_layout.add_widget(stages_box)

        # Velocity Box
        velocity_box = BoxLayout(orientation='vertical', spacing=10, size_hint = (1,None), height = 150)
        velocity_label = Label(text="Velocity", font_size='20sp', bold=True)
        velocity_box.add_widget(velocity_label)

        # X, Y, Z inputs for Velocity
        self.velocity_inputs = {}  # Store references to update later

        for axis in ['X', 'Y', 'Z']:
            axis_layout = BoxLayout(orientation='horizontal', spacing=5)
            axis_label = Label(text=f"{axis}-axis:")
            axis_input = TextInput(
                text="0.00 mm/s",
                readonly=True,
                multiline=False,
                background_color=(0.9, 0.9, 0.9, 1),  # Light gray background
                foreground_color=(0, 0, 0, 1),        # Black text
                cursor_color=(0, 0, 0, 0),            # Hide blinking cursor
                halign="center",                     # Optional: center text
                font_size='16sp'                     # Optional: better visibility              
        
            )
            axis_layout.add_widget(axis_label)
            axis_layout.add_widget(axis_input)
            velocity_box.add_widget(axis_layout)
            self.velocity_inputs[axis] = axis_input


        right_layout.add_widget(velocity_box)

        # Display Position Box
        display_position_box = BoxLayout(orientation='vertical', spacing=10)
        display_label = Label(text="Display Position", font_size='20sp', bold=True)
        display_position_box.add_widget(display_label)
        
        self.display_position_inputs = {}

        # X, Y, Z text fields for Display Position (non-editable for now)
        for axis in ['X', 'Y', 'Z']:
            axis_layout = BoxLayout(orientation='horizontal', spacing=5)
            axis_label = Label(text=f"{axis}-axis:")
            axis_display = TextInput(hint_text=f"{axis}-axis Position", readonly=True, multiline=False)
            axis_layout.add_widget(axis_label)
            axis_layout.add_widget(axis_display)
            display_position_box.add_widget(axis_layout)
            
            self.display_position_inputs[axis] = axis_display

        right_layout.add_widget(display_position_box)

        content_layout.add_widget(right_layout)
        main_layout.add_widget(content_layout)
        self.add_widget(main_layout)
        
        

        # Schedule ADC data updates
        Clock.schedule_interval(self.update_adc_data, 0.1)
        #Clock.schedule_interval(self.update_velocity_gui, 0.1)
        
        
    def update_velocity_display(self, x_velocity, y_velocity):
         print(f"[UI Update] X: {x_velocity:.2f} mm/s, Y: {y_velocity:.2f} mm/s")
         self.velocity_inputs['X'].text = f"{x_velocity:.2f} mm/s"
         self.velocity_inputs['Y'].text = f"{y_velocity:.2f} mm/s"
         self.velocity_inputs['Z'].text = "0.00 mm/s"        
         
         
                    
        
    def update_velocity_gui(self, dt):
        global current_x_velocity, current_y_velocity
        self.velocity_inputs['X'].text = f"{current_x_velocity:.2f} mm/s"
        self.velocity_inputs['Y'].text = f"{current_y_velocity:.2f} mm/s"
        self.velocity_inputs['Z'].text = "0.00 mm/s"
    
    def update_adc_data(self, dt):
        """
        Updates the ADC data display with the latest value from the ADS1115 ADC.
        """
        try:
            adc_value = self.chan.voltage  # Read actual ADC voltage
            for i, label in enumerate(self.adc_data_display):
                label.text = f"ADC Value {i + 1}: {adc_value:.2f} V"
            
                
                
        except Exception as e:
            for label in self.adc_data_display:
                label.text = f"Error reading ADC: {e}"
                
                

    def analyze_image_with_ai(self, image_path):
        try:
            url = "http://127.0.0.1:8000/analyze"
            with open(image_path, "rb") as image_file:
                files = {"file": image_file}
                response = requests.post(url, files=files)
            return response.json() if response.ok else {"error": "API error"}
        except Exception as e:
            return {"error": str(e)}




                
    def start_scan(self, *args):
            try:
                sampling_rate = float(self.sampling_rate_input.text)
                y_axis_value = float(self.y_axis_input.text)
                z_axis_value = float(self.z_axis_input.text)

                move_third_actuator(self.motor_z, z_axis_value)

                reset_axes(self.motor_x, self.motor_y, self.steps_per_mm)
                
                
                
                move_in_zigzag_pattern(self.motor_x, self.motor_y, self.chan, sampling_rate, y_axis_value,self.steps_per_mm, update_velocity = self.update_velocity_display)
                image_path = generate_heatmap(data_matrix)
                analysis_result = self.analyze_image_with_ai(image_path)

                self.image_widget.source = image_path
                self.image_widget.opacity = 1
                self.image_widget.reload()  # Forces the widget to reload the image
                self.scanned_image_label.text = "Scanning Complete. Heatmap displayed above."
               
                if "error" in analysis_result:
                    self.scanned_image_label.text += f"\n[AI Error] {analysis_result['error']}"
                else:
                    heur = analysis_result.get("heuristic", {})
                    summary = (f"\n[AI Feedback]"
                               f"\n - Object: {heur.get('object', 'N/A')}"
                               f"\n - Threat: {heur.get('threat_score', 'N/A')}"
                               f"\n - Sharpness: {heur.get('sharpness', 'N/A')}")
                    self.scanned_image_label.text += summary
               
               
               
               
               
                # Calculate total Y increments and X passes
                y_increments = int(130 / y_axis_value)
                x_passes = len(data_matrix)  
                # Update Display Position box fields
                self.display_position_inputs['X'].text = str(x_passes)
                self.display_position_inputs['Y'].text = str(y_increments)
                self.display_position_inputs['Z'].text = "0.00 mm"  # or str(z_axis_value) if you want to reflect user input                             

            except ValueError:
                self.scanned_image_label.text = "Invalid input. Please enter valid numbers."
    
    

   
    def open_previous_scans(self, *args):
            self.manager.current = 'previous_scans'    
    

# Previous Scans Screen
class PreviousScansScreen(Screen):
    def __init__(self, **kwargs):
        super(PreviousScansScreen, self).__init__(**kwargs)

        self.layout = BoxLayout(orientation='vertical')
        self.scroll_view = ScrollView(size_hint=(1, 1))
        self.outer_layout = BoxLayout(orientation='vertical', spacing=20, size_hint_y=None, padding=10)
        self.outer_layout.bind(minimum_height=self.outer_layout.setter('height'))

        self.scroll_view.add_widget(self.outer_layout)
        self.layout.add_widget(self.scroll_view)

        back_button = Button(text="Back", size_hint=(1, None), height=50)
        back_button.bind(on_release=self.go_back)
        self.layout.add_widget(back_button)

        self.add_widget(self.layout)

    def on_pre_enter(self, *args):
        self.load_images()  # Reloads every time you navigate to this screen

    def load_images(self):
        self.outer_layout.clear_widgets()

        images = sorted(
            [img for img in os.listdir(IMAGE_DIRECTORY) if img.endswith(('.png', '.jpg', '.jpeg'))],
            key=lambda x: os.path.getmtime(os.path.join(IMAGE_DIRECTORY, x)),
            reverse=True
        )

        images_per_row = 2
        for i in range(0, len(images), images_per_row):
            row_layout = BoxLayout(orientation='horizontal', spacing=15, size_hint_y=None, height=220, padding=10)
            for img_file in images[i:i + images_per_row]:
                img_path = os.path.join(IMAGE_DIRECTORY, img_file)
                image = Image(source=img_path, size_hint=(None, None), size=(300, 200))
                row_layout.add_widget(image)
            self.outer_layout.add_widget(row_layout)

    def go_back(self, *args):
        self.manager.current = 'main'



# Main App
class mmWaveApp(App):
    def build(self):
        sm = ScreenManager()
        sm.add_widget(IntroScreen(name='intro'))
        sm.add_widget(MainScreen(name='main'))
        sm.add_widget(PreviousScansScreen(name='previous_scans'))
        sm.current = 'intro'
        return sm

if __name__ == '__main__':
    mmWaveApp().run()


import random
import time
import os
import board
import threading 
from adafruit_motorkit import MotorKit
from adafruit_motor import stepper
import adafruit_ads1x15.ads1115 as ADS
from adafruit_ads1x15.analog_in import AnalogIn
from kivy.app import App
from kivy.uix.boxlayout import BoxLayout
from kivy.uix.anchorlayout import AnchorLayout
from kivy.uix.button import Button
from kivy.uix.label import Label
from kivy.uix.textinput import TextInput
from kivy.uix.screenmanager import ScreenManager, Screen
from kivy.uix.scrollview import ScrollView
from kivy.uix.image import Image
from kivy.clock import Clock
import matplotlib.pyplot as plt
import seaborn as sns
import numpy as np
from scipy.ndimage import gaussian_filter
from datetime import datetime
from kivy.core.window import Window
from kivy.uix.widget import Widget
from kivy.graphics import Color, Rectangle
from kivy.uix.floatlayout import FloatLayout
import requests


# Global Variables
data_matrix = []
IMAGE_DIRECTORY = "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection/KIVY GUI"
current_x_velocity = 0
current_y_velocity = 0.0
x_velocities = []
y_velocities = []



#Fucntion to Reset axes
def reset_axes(motor_x, motor_y, steps_per_mm, travel_distance_x=110, travel_distance_y=130):
    x_reset_distance = 5  # Stop 5 mm from origin
    y_reset_distance = travel_distance_y

    x_steps_to_reset = int((travel_distance_x - x_reset_distance) * steps_per_mm)
    y_steps_to_reset = int(y_reset_distance * steps_per_mm)

    print("Resetting Y-axis to origin...")
    move_motor(motor_y, y_steps_to_reset, stepper.BACKWARD)
    print("Y-axis reset complete.")

    print("Resetting X-axis to 5 mm from origin...")
    move_motor(motor_x, x_steps_to_reset, stepper.BACKWARD)
    print("X-axis reset complete.")


# Function to move the Z-axis actuator

def move_third_actuator(motor_z, distance_mm, steps_per_mm=10):
    print(f"Moving Z-axis by {distance_mm} mm...")
    steps = int(distance_mm * steps_per_mm)
    for _ in range(steps):
        motor_z.onestep(direction=stepper.FORWARD)
        time.sleep(0.01)
    print("Z-axis movement complete.") 

 

# Fucntion Move Motor
def move_motor(motor, steps, direction):
    start_time = time.time()
    for _ in range(steps):
        motor.onestep(direction = direction)
        time.sleep(0.002)
    end_time = time.time()
    return end_time - start_time

# Helper to safely schedule velocity updates from threads
def update_velocity_scheduled(xv, yv, update_velocity):
    def updater(dt):
        update_velocity(xv, yv)
    return updater



        
# Function to continuously read ADC in a separate thread
def acquire_adc_data(chan, sampling_rate, data_list, stop_event):
    interval = 1 / sampling_rate  # How often to sample ADC
    while not stop_event.is_set():
        data_list.append(chan.voltage)  # Read actual ADC value
        time.sleep(interval)  # Sleep based on sampling rate

#Zig Zag Fucntion
def move_in_zigzag_pattern(motor_x, motor_y, chan, sampling_rate, step_increment_y, steps_per_mm,update_velocity):
    global data_matrix, x_velocities, y_velocities
    data_matrix = []
    print(f"Starting zig-zag scan with sampling rate {sampling_rate} Hz and Y-axis increment {step_increment_y} mm...")

    total_x_steps = int(110 * steps_per_mm)
    total_y_steps = int(step_increment_y * steps_per_mm)
    total_y_increments = int(130 / step_increment_y)
    y_increment_count = 0

    stop_event = threading.Event()

    for i in range(total_y_increments):
        
        # Forward X scan
        row_data = []
        stop_event.clear()
        adc_thread = threading.Thread(target=acquire_adc_data, args=(chan, sampling_rate, row_data, stop_event))
        adc_thread.start()
        global current_x_velocity, current_y_velocity
        duration = move_motor(motor_x, total_x_steps, stepper.FORWARD)
        stop_event.set()
        adc_thread.join()
        data_matrix.append(row_data)
        
        # Calculate and update velocity
        
        
        x_velocity = 110 / duration if duration > 0 else 0
        y_velocity = step_increment_y / (0.002 * total_y_steps)
        #current_x_velocity = x_velocity
        #current_y_velocity = y_velocity
        print(f"[Terminal] X Velocity: {x_velocity:.2f} mm/s, Y Velocity: {y_velocity:.2f} mm/s")
        x_velocities.append(x_velocity)
        y_velocities.append(y_velocity)
        
        



        move_motor(motor_y, total_y_steps, stepper.FORWARD)
        y_increment_count += 1
        if y_increment_count > total_y_increments + 1:
            break

        # Backward X scan
        row_data = []
        stop_event.clear()
        adc_thread = threading.Thread(target=acquire_adc_data, args=(chan, sampling_rate, row_data, stop_event))
        adc_thread.start()
        duration=move_motor(motor_x, total_x_steps, stepper.BACKWARD)
        stop_event.set()
        adc_thread.join()
        row_data.reverse()
        data_matrix.append(row_data)
        
        
        x_velocity = 110 / duration if duration > 0 else 0
        y_velocity = step_increment_y / (0.002 * total_y_steps)
        #current_x_velocity = x_velocity
        #current_y_velocity = y_velocity
        print(f"[Terminal] X Velocity: {x_velocity:.2f} mm/s, Y Velocity: {y_velocity:.2f} mm/s")
        x_velocities.append(x_velocity)
        y_velocities.append(y_velocity)
        
        




        move_motor(motor_y, total_y_steps, stepper.FORWARD)
        y_increment_count += 1
        if y_increment_count > total_y_increments + 1:
            break
    
    avg_x_velocity = sum(x_velocities) / len(x_velocities) if x_velocities else 0
    avg_y_velocity = sum(y_velocities) / len(y_velocities) if y_velocities else 0

    Clock.schedule_once(lambda dt: update_velocity(avg_x_velocity, avg_y_velocity))
    
    print("✔ Zig-zag scanning complete.")
    


# Function to generate heatmap
def generate_heatmap(data_matrix):
    print("Generating heatmap...")
    max_length = max(len(row) for row in data_matrix)
    padded_data_matrix = np.full((len(data_matrix), max_length), np.nan)
    for i, row in enumerate(data_matrix):
        padded_data_matrix[i, :len(row)] = row
    data_matrix_filtered = gaussian_filter(np.nan_to_num(padded_data_matrix), sigma=1)
    plt.figure(figsize=(10, 8))
    sns.heatmap(data_matrix_filtered, cmap="coolwarm", xticklabels=False, yticklabels=False,
                mask=np.isnan(padded_data_matrix), cbar_kws={'label': 'Voltage (V)','shrink' : 0.8})
    plt.title('mmWave Signal Intensity (V)',fontsize = 20)
    plt.xlabel('X Position (cm)',fontsize = 16)
    plt.ylabel('Y Position (cm)',fontsize = 16)
    timestamp = datetime.now().strftime("%Y-%m-%d_%H-%M-%S")
    #desktop_path = os.path.join(os.path.expanduser("~"), "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection")
    save_path = "/home/furdeengregg/Desktop/Senior Design Team & Gregg Data Collection/KIVY GUI"
    heatmap_filename = os.path.join(save_path, f"heatmap_{timestamp}.png")
    plt.savefig(heatmap_filename)
    print(f"Heatmap saved as {heatmap_filename}")
    return heatmap_filename

# Intro Screen
class IntroScreen(Screen):
    def __init__(self, **kwargs):
        super(IntroScreen, self).__init__(**kwargs)
        layout = AnchorLayout(anchor_x = 'center', anchor_y = 'center')
        # Add the company logo 
        logo = Image(source='/home/furdeengregg/Downloads/Scan.png', 
                     size_hint=(None, None), size=(500, 500)) 
        layout.add_widget(logo)        
        self.add_widget(layout)

    def on_enter(self):
        Clock.schedule_once(self.switch_to_main, 5)

    def switch_to_main(self, *args):
        self.manager.current = 'main'

# Main Screen
class MainScreen(Screen):
    def __init__(self, **kwargs):
        super(MainScreen, self).__init__(**kwargs)

        # Initialize MotorKit instances
        self.kit1 = MotorKit(address=0x60)  # First bonnet
        self.kit2 = MotorKit(address=0x61)  # Second bonnet
        
        # Define Steps_per_mm
        self.steps_per_mm = 200 /( 2 * 3.14 * 10) 

        # Define motors
        self.motor_x = self.kit1.stepper1
        self.motor_y = self.kit1.stepper2
        self.motor_z = self.kit2.stepper1

        # Initialize I2C and ADC
        i2c = board.I2C()
        ads = ADS.ADS1115(i2c)
        self.chan = AnalogIn(ads, ADS.P0)

        main_layout = BoxLayout(orientation='vertical', padding=20, spacing=20)
        # Title at the top, centered and in red
        title_label = Label(
            text="ScanProTech",
            font_size='40sp',
            color=(1, 0, 0, 1),  # Red color
            bold=True,
            size_hint=(1, None),
            height=50
        ) 
        title_box = BoxLayout(size_hint=(1, None), height=60)
        title_box.add_widget(title_label)
        main_layout.add_widget(title_box)

        content_layout = BoxLayout(orientation='horizontal', spacing=20)
        left_layout = BoxLayout(orientation='vertical', spacing=20, size_hint=(0.8, 1))
        # Use FloatLayout for layering black background and image
        image_container = FloatLayout(size_hint=(1, 0.7))
        with image_container.canvas.before:
            Color(0, 0, 0, 1)  # Black background
            self.bg_rect = Rectangle(size=image_container.size, pos=image_container.pos)

        def update_bg_rect(instance, value):
            self.bg_rect.size = instance.size
            self.bg_rect.pos = instance.pos

        image_container.bind(pos=update_bg_rect, size=update_bg_rect)

        self.image_widget = Image(
            source="",  # Don't use None
            size_hint=(1, 1),
            pos_hint={'x': 0 ,'y': 0},
            opacity=0
        )
        image_container.add_widget(self.image_widget)
        left_layout.add_widget(image_container)
        self.scanned_image_label = Label(text="Scanned Image displayed Here", font_size='20sp', size_hint=(1, None), height=30)
        left_layout.add_widget(self.scanned_image_label)
        bottom_buttons_layout = BoxLayout(orientation='horizontal', size_hint=(1, None), height=60, padding=(10, 10))
        self.previous_scans_button = Button(text="Previous Scans")
        self.scan_now_button = Button(text="Scan Now")
        self.previous_scans_button.bind(on_release=self.open_previous_scans)
        self.scan_now_button.bind(on_release=self.start_scan)
        bottom_buttons_layout.add_widget(self.previous_scans_button)
        bottom_buttons_layout.add_widget(self.scan_now_button)
        left_layout.add_widget(bottom_buttons_layout)
        content_layout.add_widget(left_layout)

        # RAW ADC Values Section
        adc_box = BoxLayout(orientation='vertical', padding=10, spacing=10, size_hint=(1, None), height=100)
        adc_label = Label(text="RAW ADC Values", font_size='20sp', bold=True)
        adc_box.add_widget(adc_label)

        self.adc_data_display = []
        for i in range(5):  # Create 5 labels for example
            label = Label(text=f"Fetching ADC Data {i + 1}...", font_size='16sp')
            self.adc_data_display.append(label)
            adc_box.add_widget(label)  # Add each label to the ADC box
        
        left_layout.add_widget(adc_box)

        # Right Layout for Stages, Velocity, and Display Position
        right_layout = BoxLayout(orientation='vertical', spacing=20, size_hint=(0.4, 1))

        # Stages Box
        stages_box = BoxLayout(orientation='vertical', spacing=10)
        stages_label = Label(text="Stages", font_size='20sp', bold=True)
        stages_box.add_widget(stages_label)

        sampling_layout = BoxLayout(orientation='horizontal', spacing=5)
        sampling_label = Label(text="Sampling Rate:")
        self.sampling_rate_input = TextInput(hint_text="Enter Sampling Rate", multiline=False)
        sampling_layout.add_widget(sampling_label)
        sampling_layout.add_widget(self.sampling_rate_input)
        stages_box.add_widget(sampling_layout)

        y_axis_layout = BoxLayout(orientation='horizontal', spacing=5)
        y_axis_label = Label(text="Y-axis:")
        self.y_axis_input = TextInput(hint_text="Enter Y-axis Value", multiline=False)
        y_axis_layout.add_widget(y_axis_label)
        y_axis_layout.add_widget(self.y_axis_input)
        stages_box.add_widget(y_axis_layout)

        z_axis_layout = BoxLayout(orientation='horizontal', spacing=5)
        z_axis_label = Label(text="Z-axis:")
        self.z_axis_input = TextInput(hint_text="Enter Z-axis Value", multiline=False)
        z_axis_layout.add_widget(z_axis_label)
        z_axis_layout.add_widget(self.z_axis_input)
        stages_box.add_widget(z_axis_layout)

        right_layout.add_widget(stages_box)

        # Velocity Box
        velocity_box = BoxLayout(orientation='vertical', spacing=10, size_hint = (1,None), height = 150)
        velocity_label = Label(text="Velocity", font_size='20sp', bold=True)
        velocity_box.add_widget(velocity_label)

        # X, Y, Z inputs for Velocity
        self.velocity_inputs = {}  # Store references to update later

        for axis in ['X', 'Y', 'Z']:
            axis_layout = BoxLayout(orientation='horizontal', spacing=5)
            axis_label = Label(text=f"{axis}-axis:")
            axis_input = TextInput(
                text="0.00 mm/s",
                readonly=True,
                multiline=False,
                background_color=(0.9, 0.9, 0.9, 1),  # Light gray background
                foreground_color=(0, 0, 0, 1),        # Black text
                cursor_color=(0, 0, 0, 0),            # Hide blinking cursor
                halign="center",                     # Optional: center text
                font_size='16sp'                     # Optional: better visibility              
        
            )
            axis_layout.add_widget(axis_label)
            axis_layout.add_widget(axis_input)
            velocity_box.add_widget(axis_layout)
            self.velocity_inputs[axis] = axis_input


        right_layout.add_widget(velocity_box)

        # Display Position Box
        display_position_box = BoxLayout(orientation='vertical', spacing=10)
        display_label = Label(text="Display Position", font_size='20sp', bold=True)
        display_position_box.add_widget(display_label)
        
        self.display_position_inputs = {}

        # X, Y, Z text fields for Display Position (non-editable for now)
        for axis in ['X', 'Y', 'Z']:
            axis_layout = BoxLayout(orientation='horizontal', spacing=5)
            axis_label = Label(text=f"{axis}-axis:")
            axis_display = TextInput(hint_text=f"{axis}-axis Position", readonly=True, multiline=False)
            axis_layout.add_widget(axis_label)
            axis_layout.add_widget(axis_display)
            display_position_box.add_widget(axis_layout)
            
            self.display_position_inputs[axis] = axis_display

        right_layout.add_widget(display_position_box)

        content_layout.add_widget(right_layout)
        main_layout.add_widget(content_layout)
        self.add_widget(main_layout)
        
        

        # Schedule ADC data updates
        Clock.schedule_interval(self.update_adc_data, 0.1)
        #Clock.schedule_interval(self.update_velocity_gui, 0.1)
        
        
    def update_velocity_display(self, x_velocity, y_velocity):
         print(f"[UI Update] X: {x_velocity:.2f} mm/s, Y: {y_velocity:.2f} mm/s")
         self.velocity_inputs['X'].text = f"{x_velocity:.2f} mm/s"
         self.velocity_inputs['Y'].text = f"{y_velocity:.2f} mm/s"
         self.velocity_inputs['Z'].text = "0.00 mm/s"        
         
         
                    
        
    def update_velocity_gui(self, dt):
        global current_x_velocity, current_y_velocity
        self.velocity_inputs['X'].text = f"{current_x_velocity:.2f} mm/s"
        self.velocity_inputs['Y'].text = f"{current_y_velocity:.2f} mm/s"
        self.velocity_inputs['Z'].text = "0.00 mm/s"
    
    def update_adc_data(self, dt):
        """
        Updates the ADC data display with the latest value from the ADS1115 ADC.
        """
        try:
            adc_value = self.chan.voltage  # Read actual ADC voltage
            for i, label in enumerate(self.adc_data_display):
                label.text = f"ADC Value {i + 1}: {adc_value:.2f} V"
            
                
                
        except Exception as e:
            for label in self.adc_data_display:
                label.text = f"Error reading ADC: {e}"
                
                

    def analyze_image_with_ai(self, image_path):
        try:
            url = "http://127.0.0.1:8000/analyze"
            with open(image_path, "rb") as image_file:
                files = {"file": image_file}
                response = requests.post(url, files=files)
            return response.json() if response.ok else {"error": "API error"}
        except Exception as e:
            return {"error": str(e)}




                
    def start_scan(self, *args):
            try:
                sampling_rate = float(self.sampling_rate_input.text)
                y_axis_value = float(self.y_axis_input.text)
                z_axis_value = float(self.z_axis_input.text)

                move_third_actuator(self.motor_z, z_axis_value)

                reset_axes(self.motor_x, self.motor_y, self.steps_per_mm)
                
                
                
                move_in_zigzag_pattern(self.motor_x, self.motor_y, self.chan, sampling_rate, y_axis_value,self.steps_per_mm, update_velocity = self.update_velocity_display)
                image_path = generate_heatmap(data_matrix)
                analysis_result = self.analyze_image_with_ai(image_path)

                self.image_widget.source = image_path
                self.image_widget.opacity = 1
                self.image_widget.reload()  # Forces the widget to reload the image
                self.scanned_image_label.text = "Scanning Complete. Heatmap displayed above."
               
                if "error" in analysis_result:
                    self.scanned_image_label.text += f"\n[AI Error] {analysis_result['error']}"
                else:
                    heur = analysis_result.get("heuristic", {})
                    summary = (f"\n[AI Feedback]"
                               f"\n - Object: {heur.get('object', 'N/A')}"
                               f"\n - Threat: {heur.get('threat_score', 'N/A')}"
                               f"\n - Sharpness: {heur.get('sharpness', 'N/A')}")
                    self.scanned_image_label.text += summary
               
               
               
               
               
                # Calculate total Y increments and X passes
                y_increments = int(130 / y_axis_value)
                x_passes = len(data_matrix)  
                # Update Display Position box fields
                self.display_position_inputs['X'].text = str(x_passes)
                self.display_position_inputs['Y'].text = str(y_increments)
                self.display_position_inputs['Z'].text = "0.00 mm"  # or str(z_axis_value) if you want to reflect user input                             

            except ValueError:
                self.scanned_image_label.text = "Invalid input. Please enter valid numbers."
    
    

   
    def open_previous_scans(self, *args):
            self.manager.current = 'previous_scans'    
    

# Previous Scans Screen
class PreviousScansScreen(Screen):
    def __init__(self, **kwargs):
        super(PreviousScansScreen, self).__init__(**kwargs)

        self.layout = BoxLayout(orientation='vertical')
        self.scroll_view = ScrollView(size_hint=(1, 1))
        self.outer_layout = BoxLayout(orientation='vertical', spacing=20, size_hint_y=None, padding=10)
        self.outer_layout.bind(minimum_height=self.outer_layout.setter('height'))

        self.scroll_view.add_widget(self.outer_layout)
        self.layout.add_widget(self.scroll_view)

        back_button = Button(text="Back", size_hint=(1, None), height=50)
        back_button.bind(on_release=self.go_back)
        self.layout.add_widget(back_button)

        self.add_widget(self.layout)

    def on_pre_enter(self, *args):
        self.load_images()  # Reloads every time you navigate to this screen

    def load_images(self):
        self.outer_layout.clear_widgets()

        images = sorted(
            [img for img in os.listdir(IMAGE_DIRECTORY) if img.endswith(('.png', '.jpg', '.jpeg'))],
            key=lambda x: os.path.getmtime(os.path.join(IMAGE_DIRECTORY, x)),
            reverse=True
        )

        images_per_row = 2
        for i in range(0, len(images), images_per_row):
            row_layout = BoxLayout(orientation='horizontal', spacing=15, size_hint_y=None, height=220, padding=10)
            for img_file in images[i:i + images_per_row]:
                img_path = os.path.join(IMAGE_DIRECTORY, img_file)
                image = Image(source=img_path, size_hint=(None, None), size=(300, 200))
                row_layout.add_widget(image)
            self.outer_layout.add_widget(row_layout)

    def go_back(self, *args):
        self.manager.current = 'main'



# Main App
class mmWaveApp(App):
    def build(self):
        sm = ScreenManager()
        sm.add_widget(IntroScreen(name='intro'))
        sm.add_widget(MainScreen(name='main'))
        sm.add_widget(PreviousScansScreen(name='previous_scans'))
        sm.current = 'intro'
        return sm

if __name__ == '__main__':
    mmWaveApp().run()




self.image_widget = Image(size_hint=(1, 0.7))
left.add_widget(self.image_widget)

# Spacer between image and AI feedback
left.add_widget(Widget(size_hint=(1, None), height=15))

# AI Feedback box
self.feedback_box = Label(
    text="",
    size_hint=(1, None),
    height=150,
    color=(1, 1, 1, 1),
    halign="left",
    valign="top"
)
with self.feedback_box.canvas.before:
    Color(1, 1, 1, 1)
    self.feedback_bg = Rectangle(pos=self.feedback_box.pos, size=self.feedback_box.size)
self.feedback_box.bind(pos=self.update_feedback_bg, size=self.update_feedback_bg)
left.add_widget(self.feedback_box)

# Spacer between feedback and buttons
left.add_widget(Widget(size_hint=(1, None), height=15))

# Scan Buttons
btn_box = BoxLayout(size_hint=(1, None), height=50)
